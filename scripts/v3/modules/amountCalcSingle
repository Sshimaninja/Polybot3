import { BigNumber as BN } from "bignumber.js";
import { TickMath } from '@uniswap/v3-sdk';
import { TickListDataProvider } from '@uniswap/v3-sdk';
import { Pool } from '@uniswap/v3-sdk';
/**
 * 
 * @param tickList 
 * @param tickSpacing 
 * @param targetPrice 
 * @param slippageTolerance 
 * @returns maximum trade size for a given pair, taking into account slippage
 */
export async function getTradeSizeV3(tickSpacing: number, targetPrice: BN, slippageTolerance: BN): Promise<BN> {

	const tickDataProvider = new TickListDataProvider(PoolA);

	const tickList = await tickDataProvider.getTickList(poolMatch.poolID0.id, poolMatch.poolID0.tickSpacing);

	// Calculate the expected trade size without considering slippage
	const expectedTradeSize = TickMath.getAmount0Delta(tickList.lower, tickList.upper, tickSpacing, targetPrice.toNumber(), false);

	// Calculate the maximum allowed slippage in the trade
	const maxSlippage = expectedTradeSize.multipliedBy(slippageTolerance);

	// Calculate the required tokenIn considering slippage
	const requiredTokenIn = maxSlippage;

	// If this is negative, then the trade would need to be reversed, which is additional complexity to be handled later
	return requiredTokenIn.gt(0) ? requiredTokenIn : new BN(0);
}



// export async function getTradeSize(reserveIn: BN, reserveOut: BN, targetPrice: BN, slippageTolerance: BN): Promise<BN> {
// 	// Calculate the expected trade size without considering slippage
// 	// ex reserveIn/reserveOut: 300000 / 10
// 	// currentPrice = 30000 / 1
// 	// targetPrice = 30000 / 1.2 = 25000
// 	const expectedTradeSize = reserveIn.minus(targetPrice.multipliedBy(reserveOut)); // 300000 - (25000 * 10) = 50000

// 	// Calculate the maximum allowed slippage in the trade
// 	const maxSlippage = expectedTradeSize.multipliedBy(slippageTolerance); //50000 * 0.1 = 5000

// 	// Calculate the required tokenIn considering slippage
// 	const requiredTokenIn = maxSlippage; // 5000

// 	// If this is negative, then the trade would need to be reversed, which is additional complexity to be handled later
// 	// return requiredTokenIn;
// 	return requiredTokenIn.gt(0) ? requiredTokenIn : new BN(0);
// }

